/*
*   The data type 'double' is not the most accurate. It will loss some
* data when it does multiplication or division or other operations.
* But the fraction will not loss data unless the number is out of range.
* So when you use it, take care that not let the fraction be out of
* range. Though in most situation, the fraction will not be out of
* range, many prime numbers multiply will make the number out of range.
* So when you make too many numbers multiply together, using data type
* 'double' will be safe.
*
*   In future I will write a header files about matrix. Using fracton,
* the determinant's culculation will be more accurate.
* 
*   Pay attention that if you use the type 'fract' in an expression,
* wherever this variable is, the type 'fract' will be returned by the
* expression.
*
*   Now it can only determine 8 decimal places of a double. If your
* double has more decimal places, something will go wrong.
*
*
* Writen by a student, who is a newbie in Northeastern University in Shenyang Province.
*/
#ifndef FRACT
#define FRACT
#include <iostream>

//The accuracy of ascertaining the decimal place.
#define Double_Accuracy 0.00000001
//The function of ascertaining the decimal place.
int ascertain(double);
//
//
class fract{//fraction
	//To return the ansolute value of a fract.
	friend fract abs(const fract&);
	//The input and output of a fract.
	friend std::istream& operator>>(std::istream&, fract&);
	friend std::ostream& operator<<(std::ostream&, const fract&);
	//The operator of determine the size.
	//The lvalue and rvalue are both fract.
	friend bool operator<(const fract&, const fract&);
	friend bool operator<=(const fract&, const fract&);
	friend bool operator>(const fract&, const fract&);
	friend bool operator>=(const fract&, const fract&);
	friend bool operator==(const fract&, const fract&);
	//The lvalue is an int while rvalue is a fract.
	friend bool operator<(const int&, const fract&);
	friend bool operator<=(const int&, const fract&);
	friend bool operator>(const int&, const fract&);
	friend bool operator>=(const int&, const fract&);
	friend bool operator==(const int&, const fract&);
	//The lvalue is a fract while rvalue is an int.
	friend bool operator<(const fract&, const int&);
	friend bool operator<=(const fract&, const int&);
	friend bool operator>(const fract&, const int&);
	friend bool operator>=(const fract&, const int&);
	friend bool operator==(const fract&, const int&);
	//The lvalue is a double while rvalue is a fract.
	friend bool operator<(const double&, const fract&);
	friend bool operator<=(const double&, const fract&);
	friend bool operator>(const double&, const fract&);
	friend bool operator>=(const double&, const fract&);
	friend bool operator==(const double&, const fract&);
	//The lvalue is a fract while rvalue is a double.
	friend bool operator<(const fract&, const double&);
	friend bool operator<=(const fract&, const double&);
	friend bool operator>(const fract&, const double&);
	friend bool operator>=(const fract&, const double&);
	friend bool operator==(const fract&, const double&);
public:
	//All the constructors
	fract() :num(0), den(1){}
	fract(const int &i) :num(i), den(1){}
	fract(const int &i, const int &j) :num(i), den(j){ reduct(); }
	fract(double i) :den(1)
	{
		int n = ascertain(i);
		
		for (int m = 0; m < n; m++){
			i *= 10;
			den *= 10;
		}
		num = i;
		reduct();
	}
public:
	fract& operator+=(const fract&);
	fract& operator-=(const fract&);
	fract& operator*=(const fract&);
	fract& operator/=(const fract&);
	fract& operator%=(const fract&);
	//
	fract& operator+=(const int&);
	fract& operator-=(const int&);
	fract& operator*=(const int&);
	fract& operator/=(const int&);
	fract& operator%=(const int&);
	//
	fract& operator+=(const double&);
	fract& operator-=(const double&);
	fract& operator*=(const double&);
	fract& operator/=(const double&);
	fract& operator%=(const double&);
	//
	fract& operator++();
	fract& operator--();
	fract operator-();
public:
	//return the literal of the fraction
	double ltr();
	//To determine if the fract is an integer.
	bool is_int();
private:
	int num;//numerator
	int den;//denominator

	void reduct();//reduction of the fraction
};

fract abs(const fract&);
std::ostream& operator<<(std::ostream&, const fract&);
std::istream& operator>>(std::istream&, fract&);
//
bool operator<(const fract&, const fract&);
bool operator<=(const fract&, const fract&);
bool operator>(const fract&, const fract&);
bool operator>=(const fract&, const fract&);
bool operator==(const fract&, const fract&);
//
bool operator<(const int&, const fract&);
bool operator<=(const int&, const fract&);
bool operator>(const int&, const fract&);
bool operator>=(const int&, const fract&);
bool operator==(const int&, const fract&);
//
bool operator<(const fract&, const int&);
bool operator<=(const fract&, const int&);
bool operator>(const fract&, const int&);
bool operator>=(const fract&, const int&);
bool operator==(const fract&, const int&);
//
bool operator<(const double&, const fract&);
bool operator<=(const double&, const fract&);
bool operator>(const double&, const fract&);
bool operator>=(const double&, const fract&);
bool operator==(const double&, const fract&);
//
bool operator<(const fract&, const double&);
bool operator<=(const fract&, const double&);
bool operator>(const fract&, const double&);
bool operator>=(const fract&, const double&);
bool operator==(const fract&, const double&);
//
fract operator+(const fract&, const fract&);
fract operator-(const fract&, const fract&);
fract operator/(const fract&, const fract&);
fract operator%(const fract&, const fract&);
fract operator*(const fract&, const fract&);
//
fract operator+(const int&, const fract&);
fract operator-(const int&, const fract&);
fract operator/(const int&, const fract&);
fract operator%(const int&, const fract&);
fract operator*(const int&, const fract&);
//
fract operator+(const fract&, const int&);
fract operator-(const fract&, const int&);
fract operator/(const fract&, const int&);
fract operator%(const fract&, const int&);
fract operator*(const fract&, const int&);
//
fract operator+(const double&, const fract&);
fract operator-(const double&, const fract&);
fract operator/(const double&, const fract&);
fract operator%(const double&, const fract&);
fract operator*(const double&, const fract&);
//
fract operator+(const fract&, const double&);
fract operator-(const fract&, const double&);
fract operator/(const fract&, const double&);
fract operator%(const fract&, const double&);
fract operator*(const fract&, const double&);
//
//
inline
fract abs(const fract &i)
{ 
	return fract(abs(i.num), i.den);
}

inline
std::ostream& operator<<(std::ostream &out, const fract &rhs)
{
	out << rhs.num << "/" << rhs.den;
	return out;
}

inline
std::istream& operator>>(std::istream &in, fract &rhs)
{
	in >> rhs.num;
	if (!in)
		return in;
	in >> rhs.den;
	if (!in){
		in.clear();
		char c;
		in >> c >> rhs.den;
	}
	rhs.reduct();
	return in;
}
//
inline
bool operator<(const fract &lhs, const fract &rhs)
{
	if (lhs.num * rhs.num > 0)
		if (lhs.num * rhs.den < rhs.num * lhs.den)
			return true;
		else return false;
	else if (lhs.num < rhs.num)
		return true;
	else return false;
}

inline
bool operator<=(const fract &lhs, const fract &rhs)
{
	return (lhs == rhs || lhs < rhs);
}

inline
bool operator>(const fract &lhs, const fract &rhs)
{
	return !(lhs <= rhs);
}

inline
bool operator>=(const fract &lhs, const fract &rhs)
{
	return !(lhs < rhs);
}

inline
bool operator==(const fract &lhs, const fract &rhs)
{
	return (lhs.num == rhs.num && lhs.den == rhs.den) ? true : false;
}
//
inline
bool operator<(const int &lhs, const fract &rhs)
{
	return fract(lhs) < rhs;
}

inline
bool operator<=(const int &lhs, const fract &rhs)
{
	return fract(lhs) <= rhs;
}

inline
bool operator>(const int &lhs, const fract &rhs)
{
	return fract(lhs) > rhs;
}

inline
bool operator>=(const int &lhs, const fract &rhs)
{
	return fract(lhs) >= rhs;
}

inline
bool operator==(const int &lhs, const fract &rhs)
{
	return fract(lhs) == rhs;
}
//
inline
bool operator<(const fract &lhs, const int &rhs)
{
	return lhs < fract(rhs);
}

inline
bool operator<=(const fract &lhs, const int &rhs)
{
	return lhs <= fract(rhs);
}

inline
bool operator>(const fract &lhs, const int &rhs)
{
	return lhs > fract(rhs);
}

inline
bool operator>=(const fract &lhs, const int &rhs)
{
	return lhs >= fract(rhs);
}

inline
bool operator==(const fract &lhs, const int &rhs)
{
	return lhs == fract(rhs);
}
//
inline
bool operator<(const double &lhs, const fract &rhs)
{
	return fract(lhs) < rhs;
}

inline
bool operator<=(const double &lhs, const fract &rhs)
{
	return fract(lhs) <= rhs;
}

inline
bool operator>(const double &lhs, const fract &rhs)
{
	return fract(lhs) > rhs;
}

inline
bool operator>=(const double &lhs, const fract &rhs)
{
	return fract(lhs) >= rhs;
}

inline
bool operator==(const double &lhs, const fract &rhs)
{
	return fract(lhs) == rhs;
}
//
inline
bool operator<(const fract &lhs, const double &rhs)
{
	return lhs < fract(rhs);
}

inline
bool operator<=(const fract &lhs, const double &rhs)
{
	return lhs <= fract(rhs);
}

inline
bool operator>(const fract &lhs, const double &rhs)
{
	return lhs > fract(rhs);
}

inline
bool operator>=(const fract &lhs, const double &rhs)
{
	return lhs >= fract(rhs);
}

inline
bool operator==(const fract &lhs, const double &rhs)
{
	return lhs == fract(rhs);
}
//
inline
fract operator%(const fract &lhs, const fract &rhs)
{
	fract i(lhs);
	i %= rhs;
	return i;
}

inline
fract operator*(const fract &lhs, const fract &rhs)
{
	fract i(lhs);
	i *= rhs;
	return i;
}

inline
fract operator/(const fract &lhs, const fract &rhs)
{
	fract i(lhs);
	i /= rhs;
	return i;
}

inline
fract operator+(const fract &lhs, const fract &rhs)
{
	fract i(lhs);
	i += rhs;
	return i;
}

inline
fract operator-(const fract &lhs, const fract &rhs)
{
	fract i(lhs);
	i -= rhs;
	return i;
}
//
inline
fract operator%(const int &lhs, const fract &rhs)
{
	return fract(lhs) % rhs;
}

inline
fract operator*(const int &lhs, const fract &rhs)
{
	return fract(lhs) * rhs;
}

inline
fract operator/(const int &lhs, const fract &rhs)
{
	return fract(lhs) / rhs;
}

inline
fract operator+(const int &lhs, const fract &rhs)
{
	return fract(lhs) + rhs;
}

inline
fract operator-(const int &lhs, const fract &rhs)
{
	return fract(lhs) - rhs;
}
//
inline
fract operator%(const fract &lhs, const int &rhs)
{
	return lhs % fract(rhs);
}

inline
fract operator*(const fract &lhs, const int &rhs)
{
	return lhs * fract(rhs);
}

inline
fract operator/(const fract &lhs, const int &rhs)
{
	return lhs / fract(rhs);
}

inline
fract operator+(const fract &lhs, const int &rhs)
{
	return lhs + fract(rhs);
}

inline
fract operator-(const fract &lhs, const int &rhs)
{
	return lhs - fract(rhs);
}
//
inline
fract operator%(const double &lhs, const fract &rhs)
{
	return fract(lhs) % rhs;
}

inline
fract operator*(const double &lhs, const fract &rhs)
{
	return fract(lhs) * rhs;
}

inline
fract operator/(const double &lhs, const fract &rhs)
{
	return fract(lhs) / rhs;
}

inline
fract operator+(const double &lhs, const fract &rhs)
{
	return fract(lhs) + rhs;
}

inline
fract operator-(const double &lhs, const fract &rhs)
{
	return fract(lhs) - rhs;
}
//
inline
fract operator%(const fract &lhs, const double &rhs)
{
	return lhs % fract(rhs);
}

inline
fract operator*(const fract &lhs, const double &rhs)
{
	return lhs * fract(rhs);
}

inline
fract operator/(const fract &lhs, const double &rhs)
{
	return lhs / fract(rhs);
}

inline
fract operator+(const fract &lhs, const double &rhs)
{
	return lhs + fract(rhs);
}

inline
fract operator-(const fract &lhs, const double &rhs)
{
	return lhs - fract(rhs);
}
//
fract& fract::operator%=(const fract &rhs)
{
	fract l(abs(*this)), r(abs(rhs));
	l.num *= r.den;
	l.den *= r.den;
	r.num *= l.den;
	r.den *= l.den;
	while (l.num){
		l.num -= r.num;
		if (l.num - r.num < 0)break;
	}
	if (num * rhs.num < 0)
		*this = -l;
	else *this = l;
	reduct();
	return *this;
}

fract& fract::operator/=(const fract &rhs)
{
	num *= rhs.den;
	den *= rhs.num;
	reduct();
	return *this;
}

fract& fract::operator*=(const fract &rhs)
{
	num *= rhs.num;
	den *= rhs.den;
	reduct();
	return *this;
}

fract& fract::operator+=(const fract &rhs)
{
	num = num * rhs.den + den * rhs.num;
	den *= rhs.den;
	reduct();
	return *this;
}

inline
fract& fract::operator-=(const fract &rhs)
{
	*this += -fract(rhs);
	return *this;
}
//
inline
fract& fract::operator%=(const int &i)
{
	*this %= fract(i);
	return *this;
}

inline
fract& fract::operator/=(const int &i)
{
	*this /= fract(i);
	return *this;
}

inline
fract& fract::operator*=(const int &i)
{
	*this *= fract(i);
	return *this;
}

inline
fract& fract::operator+=(const int &i)
{
	*this += fract(i);
	return *this;
}

inline
fract& fract::operator-=(const int &i)
{
	*this -= fract(i);
	return *this;
}
//
inline
fract& fract::operator%=(const double &i)
{
	*this %= fract(i);
	return *this;
}

inline
fract& fract::operator/=(const double &i)
{
	*this /= fract(i);
	return *this;
}

inline
fract& fract::operator*=(const double &i)
{
	*this *= fract(i);
	return *this;
}

inline
fract& fract::operator+=(const double &i)
{
	*this += fract(i);
	return *this;
}

inline
fract& fract::operator-=(const double &i)
{
	*this -= fract(i);
	return *this;
}
//
inline
fract& fract::operator++()
{
	num += den;
	reduct();
	return *this;
}

inline
fract& fract::operator--()
{
	num -= den;
	reduct();
	return *this;
}

inline
fract fract::operator-()
{
	return fract(-num, den);
}
//
void fract::reduct()
{
	if (num == 0)
		den = 1;
	else{
		if (den < 0){
			num = -num;
			den = -den;
		}
		if (abs(num) > den){
			for (int n = den; n > 0; n--)
				if (!(num % n) && !(den % n)){
					num /= n;
					den /= n;
					break;
				}
		}
		else if (abs(num) < den){
			for (int n = abs(num); n > 0; n--)
				if (!(num % n) && !(den % n)){
					num /= n;
					den /= n;
					break;
				}
		}
		else{
			num /= num;
			den /= den;
		}
	}
}

inline
double fract::ltr()
{
	return double(num) / double(den);
}

inline
bool fract::is_int()
{
	return den == 1 ? true : false;
}

int ascertain(double i)
{
	int n(0);

	i = abs(i);
	while (i > Double_Accuracy){
		if (i > 1 - Double_Accuracy)
			i--;
		else{
			i *= 10;
			n++;
		}
	}
	return n;
}

#endif
