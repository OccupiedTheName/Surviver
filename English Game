#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define Position int
#define BucketSize 676

typedef struct Word *ElementType;
struct Word{
	char Name[31];
	int Weight;
	int Length;
	ElementType Next;
};
typedef struct Cell *HashTable;
struct Cell{
	int TableSize;
	ElementType *Buckets;
};

HashTable CreateTable(void);
Position Hash(ElementType);
ElementType Find(char[], HashTable);
void Insert(ElementType, HashTable);
void Free(HashTable);
int CulMaxWeight(char[], HashTable, int);

int main(){
	int i, N, MaxLength, Weight;
	char X[10001];
	ElementType word;
	HashTable H;

	H = CreateTable();
	word = (ElementType)malloc(sizeof(struct Word));
	word->Next = NULL;
	while (scanf("%d %s", &N, &X) != EOF){
		MaxLength = 0;
		for (i = 0; i<N; i++){
			scanf("%s %d", &word->Name, &word->Weight);
			word->Length = strlen(word->Name);
			if (MaxLength < word->Length)MaxLength = word->Length;
			Insert(word, H);
		}
		Weight = CulMaxWeight(X, H, MaxLength);
		if (Weight >= 0)
			printf("%d\n", Weight);
		else
			printf("-1\n");
		Free(H);
	}
}

int CulMaxWeight(char X[], HashTable H, int Maxlength)
{
	if (!strlen(X))return 0;
	else if (strlen(X) == 1){
		ElementType Aim;
		Aim = Find(X, H);
		if (!Aim)return INT_MIN;
		else return Aim->Weight;
	}
	else if (Maxlength>1){
		int TotalWeight = 0, Weight = 0, i, n;
		char Name[31], c;
		ElementType Aim;

		n = strlen(X);
		if (n > Maxlength)n = Maxlength;
		strncpy(Name, X, n);
		c = Name[1];
		for (i = 2; i <= n; i++){
			Name[i - 1] = c;
			c = Name[i];
			Name[i] = '\0';
			Aim = Find(Name, H);
			if (!Aim)continue;
			else{
				Weight = CulMaxWeight(X + i, H, Maxlength);
				if (TotalWeight < Weight + Aim->Weight)
					TotalWeight = Weight + Aim->Weight;
			}
		}
		if (TotalWeight <= 0)return INT_MIN;
		else return TotalWeight;
	}
	else{
		int Weight = 0;
		char c[2];
		ElementType Aim;

		c[1] = '\0';
		c[0] = X[0];
		Aim = Find(c, H);
		if (!Aim)return INT_MIN;
		else {
			Weight = CulMaxWeight(X + 1, H, Maxlength);
			if (Weight < 0)return INT_MAX;
			else return Aim->Weight + Weight;
		}
	}
}

HashTable CreateTable(void)
{
	int i;
	HashTable H;

	H = (HashTable)malloc(sizeof(struct Cell));
	H->TableSize = BucketSize;
	H->Buckets = (ElementType *)malloc(BucketSize * sizeof(ElementType));
	for (i = 0; i < BucketSize; i++)
		H->Buckets[i] = (ElementType)malloc(sizeof(struct Word));
	for (i = 0; i < BucketSize; i++)
		H->Buckets[i]->Next = NULL;
	return H;
}

Position Hash(char Key[])
{
	int n;
	Position Pos;

	n = strlen(Key);
	if (n == 1)
		Pos = Key[0] - 'a';
	else
		Pos = (Key[0] - 'a') * 26 + Key[1] - 'a';
	return Pos;
}

ElementType Find(char Key[], HashTable H)
{
	Position Pos = Hash(Key);
	ElementType Current;

	Current = H->Buckets[Pos]->Next;
	while (Current && strcmp(Key, Current->Name))
		Current = Current->Next;
	return Current;
}

void Insert(ElementType Key, HashTable H)
{
	ElementType Element;
	Position Pos = Hash(Key->Name);

	Element = (ElementType)malloc(sizeof(struct Word));
	strcpy(Element->Name, Key->Name);
	Element->Weight = Key->Weight;
	Element->Length = Key->Length;
	Element->Next = H->Buckets[Pos]->Next;
	H->Buckets[Pos]->Next = Element;
}

void Free(HashTable H)
{
	ElementType Current;
	int i;

	for (i = 0; i < BucketSize; i++)
		while (H->Buckets[i]->Next){
			Current = H->Buckets[i]->Next;
			if (!Current->Next){
				free(Current);
				H->Buckets[i]->Next = NULL;
			}
			else{
				while (Current->Next->Next)Current = Current->Next;
				free(Current->Next);
				Current->Next = NULL;
			}
		}
}
