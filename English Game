#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define Position int
#define BucketSize 676

enum{ FALSE, TRUE };

typedef long long WeightType;
typedef struct Word *ElementType;
struct Word{
	char Name[31];
	WeightType Weight;
	ElementType Next;
};
typedef struct Cell *HashTable;
struct Cell{
	int TableSize;
	ElementType *Buckets;
};
struct WeightJudge{
	WeightType Weight;
	bool judge;
};

HashTable CreateTable(void);
Position Hash(ElementType);
ElementType Find(char[], HashTable);
void Insert(ElementType, HashTable);
void Free(HashTable);
WeightJudge CulMaxWeight(char[], HashTable, int);

int main(){
	int i, N, MaxLength, n;
	char X[10001];
	ElementType word;
	HashTable H;
	WeightJudge Weight;

	H = CreateTable();
	word = (ElementType)malloc(sizeof(struct Word));
	word->Next = NULL;
	while (scanf("%d %s", &N, &X) != EOF){
		MaxLength = 0;
		for (i = 0; i<N; i++){
			scanf("%s %ld", &word->Name, &word->Weight);
			n = strlen(word->Name);
			if (MaxLength < n)MaxLength = n;
			Insert(word, H);
		}
		Weight = CulMaxWeight(X, H, MaxLength);
		if (Weight.judge)
			printf("%d\n", Weight.Weight);
		else
			printf("-1\n");
		Free(H);
	}
}

WeightJudge CulMaxWeight(char X[], HashTable H, int Maxlength)
{
	int n = strlen(X);
	if (!n){
		WeightJudge Weight;

		Weight.judge = TRUE;
		Weight.Weight = 0;
		return Weight;
	}
	else if (n == 1){
		WeightJudge Weight;
		ElementType Aim;

		Aim = Find(X, H);
		if (!Aim){
			Weight.judge = FALSE;
			return Weight;
		}
		else {
			Weight.judge = TRUE;
			Weight.Weight = Aim->Weight;
			return Weight;
		}
	}
	else if (Maxlength > 1){
		int i;
		char Name[31], c;
		ElementType Aim;
		WeightJudge Weight, TotalWeight;

		Weight.Weight = 0;
		TotalWeight.judge = FALSE;
		TotalWeight.Weight = -2100000000;
		if (n > Maxlength)n = Maxlength;
		strncpy(Name, X, n);
		c = Name[0];
		for (i = 1; i <= n; i++){
			Name[i - 1] = c;
			c = Name[i];
			Name[i] = '\0';
			Aim = Find(Name, H);
			if (!Aim)continue;
			else{
				Weight = CulMaxWeight(X + i, H, Maxlength);
				if (Weight.judge == TRUE)
					if (TotalWeight.Weight < Weight.Weight + Aim->Weight){
						TotalWeight.Weight = Weight.Weight + Aim->Weight;
						TotalWeight.judge = TRUE;
					}
			}
		}
		return TotalWeight;
	}
	else{
		char c[2];
		ElementType Aim;
		WeightJudge Weight, TotalWeight;

		TotalWeight.judge = FALSE;
		c[1] = '\0';
		c[0] = X[0];
		Aim = Find(c, H);
		if (!Aim){
			return TotalWeight;
		}
		else {
			Weight = CulMaxWeight(X + 1, H, Maxlength);
			if (Weight.judge){
				TotalWeight.Weight = Aim->Weight + Weight.Weight;
				TotalWeight.judge = TRUE;
			}
			return TotalWeight;
		}
	}
}

HashTable CreateTable(void)
{
	int i;
	HashTable H;

	H = (HashTable)malloc(sizeof(struct Cell));
	H->TableSize = BucketSize;
	H->Buckets = (ElementType *)malloc(BucketSize * sizeof(ElementType));
	for (i = 0; i < BucketSize; i++)
		H->Buckets[i] = (ElementType)malloc(sizeof(struct Word));
	for (i = 0; i < BucketSize; i++)
		H->Buckets[i]->Next = NULL;
	return H;
}

Position Hash(char Key[])
{
	int n;
	Position Pos;

	n = strlen(Key);
	if (n == 1)
		Pos = tolower(Key[0] - 'a');
	else
		Pos = tolower(Key[0] - 'a') * 26 + tolower(Key[1] - 'a');
	return Pos;
}

ElementType Find(char Key[], HashTable H)
{
	Position Pos = Hash(Key);
	ElementType Current;

	Current = H->Buckets[Pos]->Next;
	while (Current && strcmp(Key, Current->Name))
		Current = Current->Next;
	return Current;
}

void Insert(ElementType Key, HashTable H)
{
	ElementType Element;
	Position Pos = Hash(Key->Name);

	Element = (ElementType)malloc(sizeof(struct Word));
	strcpy(Element->Name, Key->Name);
	Element->Weight = Key->Weight;
	Element->Next = H->Buckets[Pos]->Next;
	H->Buckets[Pos]->Next = Element;
}

void Free(HashTable H)
{
	ElementType Current;
	int i;

	for (i = 0; i < BucketSize; i++)
		while (H->Buckets[i]->Next){
			Current = H->Buckets[i]->Next;
			if (!Current->Next){
				free(Current);
				H->Buckets[i]->Next = NULL;
			}
			else{
				while (Current->Next->Next)Current = Current->Next;
				free(Current->Next);
				Current->Next = NULL;
			}
		}
}
